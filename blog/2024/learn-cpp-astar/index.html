<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Shortest Path to Learn C++ (and A*) | Yorai  Shaoul</title>
    <meta name="author" content="Yorai  Shaoul">
    <meta name="description" content="A brief introduction to C++ by implementing the A* algorithm.">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.3/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="/assets/img/broken_gear.png">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://yoraish.com/blog/2024/learn-cpp-astar/">

    <!-- Dark Mode -->
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yorai </span>Shaoul</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">Projects</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">CV</a>
              </li>
              <li class="nav-item dropdown ">
                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">others</a>
                <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="/problems/">problems</a>
                  <div class="dropdown-divider"></div>
                  <a class="dropdown-item" href="/solutions/">solutions</a>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Shortest Path to Learn C++ (and A*)</h1>
    <p class="post-meta">October 27, 2024</p>
    <p class="post-tags">
      <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>
        ·  
        <a href="/blog/category/industry">
          <i class="fas fa-tag fa-sm"></i> industry</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <h1 id="the-shortest-path-to-learn-c-and-a-a-brief-recap">The Shortest Path to Learn C++ (and A*): A Brief Recap</h1>

<blockquote>
  <p>Background: In the CMU class 16-782 Planning and Decision-Making in Robotics, students are assigned multiple homework assignments that involve implementing planning algorithms in C++. This post was originally made for the students in the class when I was a TA. Related code is available <a href="https://github.com/yoraish/shortest_path_to_cpp" rel="external nofollow noopener" target="_blank">here</a>.</p>
</blockquote>

<p>C++ has been (and will likely be for at least a bit) a central programming language in robotics. It is a powerful language that is flexible and (relatively) easy to write-in, while also being fast and efficient. This post
 comes to serve as a brief recap/summary/cheatsheet of some of the basics of C++ programming. We will be implementing the A* algorithm and discussing relevant C++ elements as we go.</p>

<p>From a high level, we will complete the following tasks today, and cover the following topics in the process:</p>

<ol>
  <li>Set up the directory structure for our planner project.
    <ul>
      <li><a href="#setting-up-common-directory-structure-in-c">Common directory structure in C++ projects.</a></li>
    </ul>
  </li>
  <li>Create the main entrypoint for our program.
    <ul>
      <li><a href="#the-main-function">The <code class="language-plaintext highlighter-rouge">main</code> function.</a></li>
    </ul>
  </li>
  <li>Set up a debugger in VSCode.
    <ul>
      <li><a href="#setting-up-a-debugger-in-vscode">Setting up a debugger in VSCode</a></li>
    </ul>
  </li>
  <li>Define the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct.
    <ul>
      <li>Discussing: <code class="language-plaintext highlighter-rouge">class</code>, <code class="language-plaintext highlighter-rouge">struct</code>, <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">protected</code>, <code class="language-plaintext highlighter-rouge">virtual</code>, and <code class="language-plaintext highlighter-rouge">override</code>.</li>
      <li><a href="#classes-structs-and-objects">Classes, structs, and objects.</a></li>
    </ul>
  </li>
  <li>Add member variables and functions to the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct. Discussing: the <code class="language-plaintext highlighter-rouge">plan</code>, <code class="language-plaintext highlighter-rouge">getSuccessors</code>, and <code class="language-plaintext highlighter-rouge">computeHeuristic</code> functions.
    <ul>
      <li>Discussing: passing by reference, default arguments, and operator overloading.</li>
      <li><a href="#functions">Functions</a></li>
    </ul>
  </li>
  <li>Add <code class="language-plaintext highlighter-rouge">open</code> and <code class="language-plaintext highlighter-rouge">closed</code> lists to the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class.
    <ul>
      <li>Discussing: <code class="language-plaintext highlighter-rouge">std::vector</code>, <code class="language-plaintext highlighter-rouge">std::pair</code>, <code class="language-plaintext highlighter-rouge">std::deque</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>, and <code class="language-plaintext highlighter-rouge">std::priority_queue</code>.</li>
      <li><a href="#the-standard-library-useful-objects">The standard library: useful objects.</a></li>
    </ul>
  </li>
  <li><a href="#implementing-a">Fill in the logic for the A* algorithm and helper methods.</a></li>
</ol>

<h2 id="setting-up-common-directory-structure-in-c">Setting Up: Common Directory Structure in C++</h2>

<p>When starting a new C++ project, it is common to have a directory structure like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.  
├── CMakeLists.txt
├── include
│   └── my_project
│       └── my_class_header_file.hpp
└── src
    ├── my_class_source_file.cpp
    └── main.cpp
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">include</code> directory is where we’ll put our header files. Header files are used to declare classes, functions, and variables that are used across our program. In our case, we will have a header file for our A* algorithm, which we will call <code class="language-plaintext highlighter-rouge">astar.hpp</code>. The <code class="language-plaintext highlighter-rouge">src</code> directory is where we put our source files. These usually contain the implementation of the classes and functions declared in the header files. In our case, we will have a source file for our A* algorithm, which we will call <code class="language-plaintext highlighter-rouge">astar.cpp</code>. <code class="language-plaintext highlighter-rouge">main.cpp</code> is the entrypoint file for our program. Everything that will run will begin there (this will hopefully become clearer soon). Now, since C++ is a compiled language, we need to tell the compiler how to build our project and turn it into an executable binary which we can run. This is where the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file comes in. This file contains information for building the project.</p>

<p>To start out then, create the following directory structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── CMakeLists.txt
├── include
│   └── shortest_path_to_cpp
│       └── astar.hpp
└── src
    ├── astar.cpp
    └── main.cpp
</code></pre></div></div>

<p>In what follows we will be keeping track of three files: <code class="language-plaintext highlighter-rouge">astar.hpp</code>, <code class="language-plaintext highlighter-rouge">astar.cpp</code>, and <code class="language-plaintext highlighter-rouge">main.cpp</code>.  They will start out empty and we will gradually fill them in.</p>

<hr>

<details>
  <summary>The current state of our code files.</summary>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
</code></pre></div>  </div>

</details>

<hr>

<h2 id="the-main-function">The <code class="language-plaintext highlighter-rouge">main</code> Function</h2>
<p>C++ programs start executing at the <code class="language-plaintext highlighter-rouge">main</code> function. Whatever this function does is what the program will do! Nothing fancy here. Normally, this function will create objects, call functions, and do whatever else is needed to run the program. In our case we will construct a grid here, create an A* planner object, and call its <code class="language-plaintext highlighter-rouge">plan</code> function.</p>

<p>The <code class="language-plaintext highlighter-rouge">main</code> function is the entry point of the program, and it has the following signature:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">argc</code> parameter is the number of arguments passed to the program, and <code class="language-plaintext highlighter-rouge">argv</code> is an array of strings containing the arguments. We won’t be using these in this post, but they are useful when you want to pass arguments to your program from the command line. It’s also possible to omit these parameters from the signature if you don’t need them.</p>

<p>Let’s create a simple example before we proceed. We’ll also use this as an opportunity for setting up the build system with CMake. Start by creating all the <code class="language-plaintext highlighter-rouge">.cpp</code> and <code class="language-plaintext highlighter-rouge">.hpp</code> files in the directory structure we discussed earlier. Now, for the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file, add the following:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>shortest_path_to_cpp<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 17<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span>include/shortest_path_to_cpp<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>planner src/main.cpp src/astar.cpp<span class="p">)</span>
</code></pre></div></div>
<p>To build the project, create a <code class="language-plaintext highlighter-rouge">build</code> directory in the root of the project and run the following commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>build
cmake .. <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Debug
make
</code></pre></div></div>
<p>Change the <code class="language-plaintext highlighter-rouge">Debug</code> to <code class="language-plaintext highlighter-rouge">Release</code> if you want to build a release version of the program. This will create an executable called <code class="language-plaintext highlighter-rouge">planner</code> in the <code class="language-plaintext highlighter-rouge">build</code> directory. You can run it by running <code class="language-plaintext highlighter-rouge">./planner</code> in the terminal.</p>

<hr>

<details>
  <summary>The current state of our code files.</summary>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

</details>

<hr>

<h2 id="setting-up-a-debugger-in-vscode">Setting Up a Debugger in VSCode</h2>
<p>One crucial tool for developing in C++ is a debugger. A debugger allows you to pause your program at any point and inspect the values of variables, the call stack, and more. This is incredibly useful when you are trying to figure out why your program is not working as expected. One popular way to set up a debugger is through VSCode, and today we will do just that. It is of course possible to use other editors/IDEs (e.g., CLion), or debug directly from the terminal (e.g., with <code class="language-plaintext highlighter-rouge">gdb</code>), but we will focus on VSCode since it is free and easy to set up. On top of helping us with debugging code, VSCode can also handle build tasks for us.</p>

<p>There are two main JSON files involved in setting up the debugger and build in VSCode: <code class="language-plaintext highlighter-rouge">launch.json</code> and <code class="language-plaintext highlighter-rouge">tasks.json</code>. The <code class="language-plaintext highlighter-rouge">launch.json</code> file contains the configuration for the debugger and the <code class="language-plaintext highlighter-rouge">tasks.json</code> file contains the configuration for the build tasks. 
Let’s create these files. The first step is to open your code in VSCode. To do that (via the terminal), navigate to the directory where your code is located and run <code class="language-plaintext highlighter-rouge">code .</code>. This will open the current directory in VSCode. Now, create a <code class="language-plaintext highlighter-rouge">.vscode</code> directory in the root of your project and create the <code class="language-plaintext highlighter-rouge">launch.json</code> and <code class="language-plaintext highlighter-rouge">tasks.json</code> files in it. This can be done automatically via the GUI as well. Populate the <code class="language-plaintext highlighter-rouge">launch.json</code> file with the following:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Planner Debug"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppdbg"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/build/planner"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
            </span><span class="nl">"stopAtEntry"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"environment"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
            </span><span class="nl">"externalConsole"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="nl">"MIMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"setupCommands"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="p">{</span><span class="w">
                    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enable pretty-printing for gdb"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-enable-pretty-printing"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"preLaunchTask"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>And populate the <code class="language-plaintext highlighter-rouge">tasks.json</code> file with the following:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cmake"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"--build"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/build"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"--config"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"Debug"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"$gcc"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>In the VSCode GUI we can now go to the debug tab (ctrl + shift + D in Ubuntu) and find our <code class="language-plaintext highlighter-rouge">Planner Debug</code> configuration.
Clicking on the play button runs our program in debug mode  (make sure that your build files were created with the <code class="language-plaintext highlighter-rouge">Debug</code> CMake flag). Allow me to repeat – if this does not work <em>make sure</em> that your code was built in <code class="language-plaintext highlighter-rouge">Debug</code> mode. Delete your <code class="language-plaintext highlighter-rouge">build</code> directory and run <code class="language-plaintext highlighter-rouge">cmake .. -DCMAKE_BUILD_TYPE=Debug</code> again.</p>

<p>We can play around with the debugger: create some variables and add some breakpoints in <code class="language-plaintext highlighter-rouge">main.cpp</code> to see how it works.</p>

<hr>

<details>
  <summary>The current state of our code files.</summary>

  <p>Let’s also add a header guard to our <code class="language-plaintext highlighter-rouge">astar.hpp</code> file to prevent multiple inclusions of the file. This may become clearer later.</p>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#pragma once
</span></code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

</details>

<hr>

<h2 id="classes-structs-and-objects">Classes, Structs, and Objects</h2>
<p>Let’s begin implementing our A* planning algorithm! In this section we’ll start setting up the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct which we will us in our implementation and also discuss classes and structs in C++ more generally.</p>

<h3 id="classes">
<code class="language-plaintext highlighter-rouge">class</code>es</h3>
<p>A <code class="language-plaintext highlighter-rouge">class</code> is a user-defined data type that groups related data and functions together. Let’s discuss a few features of classes and them put them to work in our A* planner implementation.</p>

<ul>
  <li>
    <p><strong>Member Variables</strong>:
Member variables are variables that belong to a class. They are declared inside the class definition and can be accessed by any member function of the class. A member variable we care about in A* is the grid we are planning on. We will store this in the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class under the name <code class="language-plaintext highlighter-rouge">grid_</code>. The trailing underscore is a common naming convention for <a href="#access-modifiers"><code class="language-plaintext highlighter-rouge">private</code></a> member variables in C++.</p>
  </li>
  <li>
    <p><strong>Member Functions</strong>:
Similar to member variables, member functions (also called class methods) are functions that are defined in the class and can access any member of the class. They are used to perform operations on the data stored in the class with potential extra inputs. Our A* planner will have a member function called <code class="language-plaintext highlighter-rouge">plan</code> that will take a start and goal position and plan a path between them.</p>
  </li>
  <li>
    <p><strong>Constructors and Destructors</strong>:
Constructors are special member functions that are called when an object of a class is created. They are used to initialize the object’s member variables. Destructors are are similar, and are called when an object is destroyed. They are used to clean up resources used by the object. C++ provides a default constructor and destructor if you don’t define one yourself. We will store the planning grid in the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class in the constructor. We will do this in an initialization list, which is a list of member variables to initialize in the constructor. This is more efficient than initializing the variables in the constructor body.</p>
  </li>
  <li>
    <p><strong>Access Modifiers</strong>:   Access modifiers are keywords that control the visibility of class members. There are three access modifiers in C++: <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, and <code class="language-plaintext highlighter-rouge">protected</code>. Members declared as <code class="language-plaintext highlighter-rouge">public</code> can be accessed from outside the class, members declared as <code class="language-plaintext highlighter-rouge">private</code> can only be accessed from within the class, and members declared as <code class="language-plaintext highlighter-rouge">protected</code> can be accessed from within the class and by derived classes (see the next section for more on this).</p>
  </li>
  <li>
    <p><strong>Inheritance</strong>:
Inheritance is a feature of C++ that allows you to create a new class that is based on an existing class. Inherited classes (also called derived classes) include all the public and protected members of the base class (also called the parent class). This allows you to reuse code and create a hierarchy of classes. In our implementation, we will create a <code class="language-plaintext highlighter-rouge">Planner</code> base class and then create a derived class for the A* planner. Per the definition of the base class, all derived-class planners will be required to implement a <code class="language-plaintext highlighter-rouge">plan</code> function.</p>
  </li>
</ul>

<h4 id="a-planner-class">A* Planner Class</h4>
<p>Alright, less talk more do. Let’s get going with the implementation. 
We’ll use a class to represent a planning algorithm in our program, and a derived class for our A* planner. The parent class will be <em>abstract</em>, meaning that it will have at least one <em>pure virtual function</em>—a function with no implementation marked with (<code class="language-plaintext highlighter-rouge">=0</code>). This is often done to dictate the structure of derived classes and force them to implement certain functions. In our case, we will have a abstract <code class="language-plaintext highlighter-rouge">Planner</code> base class that will have the pure virtual function <code class="language-plaintext highlighter-rouge">plan</code>, The derived A* planner class will implement this function.</p>

<p>We will also add some private methods, <code class="language-plaintext highlighter-rouge">computeHeuristic</code>, <code class="language-plaintext highlighter-rouge">expand</code>, and <code class="language-plaintext highlighter-rouge">getSuccessors</code>, to help with the planning process. As a matter of convenience, we’ll create aliases to some types (i.e., shorter names to types that are long to type out and used frequently). For example, we will create an alias to <code class="language-plaintext highlighter-rouge">std::pair&lt;int, int&gt;</code>, which we use to store robot position values, and simply call it <code class="language-plaintext highlighter-rouge">Position</code>. This will make our code more readable and easier to understand. We do this with the keyword <code class="language-plaintext highlighter-rouge">using</code> (or the older <code class="language-plaintext highlighter-rouge">typedef</code>).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="cp">#pragma once
</span><span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Planner</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>

    <span class="c1">// TODO: computeHeuristic.</span>
    <span class="c1">// TODO: getSuccessors.</span>
    <span class="c1">// TODO: expand.</span>
<span class="nl">public:</span>
    <span class="c1">// Member functions.</span>
    <span class="n">Planner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="c1">// Member variables.</span>
    <span class="c1">// TODO: Open list, </span>
    <span class="c1">// TODO: closed list,</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="structs">
<code class="language-plaintext highlighter-rouge">struct</code>s</h3>
<p>A <code class="language-plaintext highlighter-rouge">struct</code> is a data type identical to a class, with the exception that its members are public by default (as opposed to private in classes). They are used to group related data together. In our implementation, we will use a <code class="language-plaintext highlighter-rouge">struct</code> to represent a state in the search.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="k">struct</span> <span class="nc">SearchState</span>
<span class="p">{</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The state of our code now, with the <code class="language-plaintext highlighter-rouge">Planner</code> and <code class="language-plaintext highlighter-rouge">AStarPlanner</code> classes and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct defined, is as follows:</p>

<hr>

<details>
  <summary>The current state of our code files.</summary>

  <p>Let’s also add a header guard to our <code class="language-plaintext highlighter-rouge">astar.hpp</code> file to prevent multiple inclusions of the file. This may become clearer later.</p>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="cp">#pragma once
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SearchState</span>
<span class="p">{</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Planner</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// Variables.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>
    <span class="c1">// TODO: open_;</span>
    <span class="c1">// TODO: closed_;</span>
    
    <span class="c1">// Methods.</span>
    <span class="c1">// TODO: computeHeuristic.</span>
    <span class="c1">// TODO: getSuccessors.</span>
<span class="nl">public:</span>
    <span class="c1">// Member functions.</span>
    <span class="n">Planner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
<span class="cp"># include &lt;astar.hpp&gt;
</span>
<span class="n">Planner</span><span class="o">::</span><span class="n">Planner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Implement the A* algorithm here.</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

</details>

<hr>

<h2 id="functions">Functions</h2>
<p>As we get ready to define the member functions of our A* algorithm, it’s worth mentioning some features of functions in C++.</p>

<ul>
  <li>
<strong>Overloading</strong>: C++ allows you to define multiple functions with the same name but different parameters. This is called function overloading. It is convenient when you want to perform the same operation on different types of data.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">float</span> <span class="nf">add</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
<strong>Default Arguments</strong>: You can provide default values for function parameters. If a value is not provided when the function is called, the default value will be used.
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
<strong>Operator Overloading</strong>: C++ allows you to redefine the behavior of operators for user-defined types. This is called operator overloading. For example, in our implementation we will define the <code class="language-plaintext highlighter-rouge">&lt;</code> operator for the <code class="language-plaintext highlighter-rouge">SearchState</code> struct to compare states based on their <code class="language-plaintext highlighter-rouge">f</code> values. (We negate the f-values to make the priority queue, which is normally a max-heap, a min-heap.)
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchState</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">other</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>Note that the <code class="language-plaintext highlighter-rouge">const</code> keyword at the end of the function declaration means that the function does not modify the object it is called on. The “const reference” <code class="language-plaintext highlighter-rouge">other</code> is explained next.</p>
  </li>
  <li>
    <p><strong>Passing Arguments</strong>: function arguments can be passed in a few ways: by value, by reference, and by pointer.</p>

    <ul>
      <li>
<strong>Pass by value</strong>: The default is by value, which means that a copy of the object is passed to the function.
        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v is copied, and the copy is modified.</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
<strong>Pass by reference</strong>: When you pass a variable by reference, you are passing the memory address of the variable instead of the value. This is more efficient than passing by value, as the entire object is not copied.
        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v is modified directly.</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
        <p>A common use case for passing by reference is when you want to modify the object passed to the function. Or in other words, if you want to “return more than one value” from a function. An example for this is below, where both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are modified.</p>
        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">assignValues</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <p>A version of passing by reference is is <strong>passing by <code class="language-plaintext highlighter-rouge">const</code> reference</strong>, which means that the object cannot be modified. This is useful when we want to use the information stored in some object without changing it.</p>
        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v cannot be modified.</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// This will not compile.</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// This is fine.</span>
  <span class="p">}</span>

</code></pre></div>        </div>
      </li>
      <li>
<strong>Pass by pointer</strong>: A pointer is a variable that stores the memory address of another variable. When you pass a variable by pointer, you are passing the memory address of the variable. This is similar to passing by reference, but you need to dereference the pointer to access the object.
        <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v is modified directly.</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p>Let’s put this to work by adding the definitions (not implementation yet) of the various functions we will need in our A* planner. We have already done the <code class="language-plaintext highlighter-rouge">plan</code> function, so let us now continue with the <code class="language-plaintext highlighter-rouge">computeHeuristic</code> and <code class="language-plaintext highlighter-rouge">getSuccessors</code> functions.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="p">...</span>
    <span class="kt">int</span> <span class="nf">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>
<h3 id="objects">Objects</h3>
<p>An object is an instance of a class or struct. In our code we’ll create, for example, an instance of the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and call its <code class="language-plaintext highlighter-rouge">plan</code> function. Let’s set up the <code class="language-plaintext highlighter-rouge">main</code> function to create a grid and call the planner.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="p">};</span>

    <span class="n">AStarPlanner</span> <span class="nf">planner</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">Position</span> <span class="n">start</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Position</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">planner</span><span class="p">.</span><span class="n">plan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is also possible to directly create a pointer to an object using the <code class="language-plaintext highlighter-rouge">new</code> keyword or <code class="language-plaintext highlighter-rouge">std::make_shared</code> function. This is useful when you want to create an object that will outlive the current scope. In our case, we will create shared pointers to <code class="language-plaintext highlighter-rouge">SearchState</code> objects. We’ll talk more about pointers in the next section.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<p>In fact, since we will be making use of this pointer quite a bit, we’ll create an alias for it to make our code more readable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">SearchStatePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<hr>

<details>
  <summary>The current state of our code files.</summary>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SearchState</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchState</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// To accommodate the priority queue, which is a max heap by default.</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">rhs</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">SearchStatePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Planner</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    
<span class="nl">private:</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// Variables.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>
    <span class="c1">// TODO: open_;</span>
    <span class="c1">// TODO: closed_;</span>
    
    <span class="c1">// Methods.</span>
    <span class="kt">int</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">);</span>

<span class="nl">public:</span>
    <span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">);</span>
    <span class="o">~</span><span class="n">AStarPlanner</span><span class="p">();</span>
    <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>

<span class="n">AStarPlanner</span><span class="o">::</span><span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner constructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">AStarPlanner</span><span class="o">::~</span><span class="n">AStarPlanner</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner destructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>


<span class="n">Path</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Plan() called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Position</span> <span class="n">start</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Position</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">planner</span><span class="o">-&gt;</span><span class="n">plan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>  </div>

</details>

<hr>

<h2 id="the-standard-library-useful-objects">The Standard Library: Useful Objects</h2>
<p>We are almost ready to implement the logic of the A* algorithm. We are only missing the OPEN and CLOSED lists. Conceptually, there are various data structures that we could use to achieve different goals. Between lists, sets, heaps, and trees, we have a lot of options.</p>

<ul>
  <li>
    <p><strong>Lists</strong> are like simple containers – they hold elements nicely, but are not ideal if we want to repeatedly sort their elements or check if elements are present.</p>
  </li>
  <li>
    <p><strong>Sets</strong> are unordered but have fast lookup times. These are often implemented as hash tables.</p>
  </li>
  <li>
    <p><strong>Maps</strong> are similar to sets, but they store key-value pairs. Getting the value associated with a key is done in constant time and checking if a key is in the map is also done in constant time.</p>
  </li>
  <li>
    <p><strong>Heaps</strong> allow us to access the element with the highest priority in constant time and insert new elements in logarithmic time.</p>
  </li>
  <li>
    <p><strong>Trees</strong> allow for fast (but not constant time) search while preserving order.</p>
  </li>
</ul>

<p>This section will discuss the C++ counterparts for these data structures and how we can use them in our implementation. Specifically, we will cover the relevant objects from the C++ standard library</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>:
A vector is a dynamic array that can grow and shrink in size. It is conceptually similar to a list that can change its size at runtime. In our implementation, we have already used vectors to represent the grid and store the path. Another use for a <code class="language-plaintext highlighter-rouge">vector</code> can be the queue of a depth-first search, for example. Searching through a vector can be done with the <code class="language-plaintext highlighter-rouge">std::find</code> function, which returns an <a href="#what-we-did-not-talk-about">iterator</a> to the element if it is found, or the end of the vector if it is not found.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Element found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::deque</code></strong>: A deque (double-ended queue) is a data structure that allows insertion and deletion at both ends. It is similar to a vector, but it is more efficient when elements are added or removed from the front of the container. This can be used as the queue in a breadth-first search, for example. Checking if an element is in a deque can be done in linear time.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">d</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Element found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>Adding and removing elements from the back and front of a deque is done like this:</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="n">d</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
  <span class="n">d</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="n">d</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::pair</code></strong> A pair is a simple container that can hold two values. It is useful when you need to return two values from a function or store two values together. In our implementation, we use pairs to represent positions on the grid.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::unordered_set</code></strong>: An unordered set is a data structure that stores unique elements in no particular order. Under the hood, it is a hash table. If hashing custom elements, you will need to provide a hash function.
In our implementation, we will use an unordered set to store the closed list of states.
Checking if an element is in an unordered set can be done in constant time.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Element found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::unordered_map</code></strong>: An unordered map is a data structure that stores key-value pairs in no particular order. If hashing custom elements, you will need to provide a hash function. A similar <code class="language-plaintext highlighter-rouge">find</code> method to the unordered set can be used to check if a key is in the map.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::priority_queue</code></strong>:
A priority queue is a data structure that stores elements in a sorted order. When elements are added to the queue, they are placed in the correct position based on their priority. The element with the highest priority is at the front of the queue. In our implementation, we will use a priority queue to store the open list of states to explore. The priority queue will make use of the <code class="language-plaintext highlighter-rouge">&lt;</code> operator we defined for the <code class="language-plaintext highlighter-rouge">SearchState</code> struct to order the states based on their <code class="language-plaintext highlighter-rouge">f</code> values.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">open_list</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>We can access the element with the highest priority in constant time with the <code class="language-plaintext highlighter-rouge">top</code> method. We can add elements to the queue with the <code class="language-plaintext highlighter-rouge">push</code> method and remove elements with the <code class="language-plaintext highlighter-rouge">pop</code> method.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">SearchStatePtr</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">state</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">open_list</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="n">open_list</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>We have already seen some pointers in this post, but we will also introduce a few more objects from the standard library that are useful in this context.</p>

<ul>
  <li>
    <p><strong>Pointers and Smart Pointers</strong>:
C++ has introduce, since C++11, a class of objects called smart pointers. These are objects that manage the memory of a pointer automatically. A <code class="language-plaintext highlighter-rouge">shared_ptr</code> is a smart pointer that can be shared among multiple objects. It keeps track of how many objects are pointing to the same memory location and deletes the memory when the last object is destroyed. In our implementation, we will use shared pointers to manage the memory of our search states. It is worth looking at a quick example of how shared pointers can be safer to work with than raw pointers.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1">// Using raw pointers</span>
  <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">SearchState</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SearchState</span><span class="p">();</span>
      <span class="c1">// Do something with state</span>
      <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Using shared pointers</span>
  <span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
      <span class="c1">// Do something with state</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>In the first function, if we were to forget deleting the <code class="language-plaintext highlighter-rouge">state</code> object, we would have a memory leak. In the second function, the <code class="language-plaintext highlighter-rouge">state</code> object will be automatically deleted when it goes out of scope (i.e., when the function ends).</p>

    <p>For any pointer, the actual object it points to can be retrieved by <em>dereferencing</em> the pointer. This is done with the <code class="language-plaintext highlighter-rouge">*</code> operator. For example, to access the <code class="language-plaintext highlighter-rouge">f</code> value of a <code class="language-plaintext highlighter-rouge">SearchState</code> object pointed to by a shared pointer, we would do the following:</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">SearchStatePtr</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">state</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">SearchState</span> <span class="n">s</span> <span class="o">=</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>The <code class="language-plaintext highlighter-rouge">auto</code> Keyword</strong>: The <code class="language-plaintext highlighter-rouge">auto</code> keyword is used to automatically deduce the type of a variable. This can be useful when the type of the variable is long or complex (but clear from context). In our implementation, we use <code class="language-plaintext highlighter-rouge">auto</code> to create a shared pointer to an <code class="language-plaintext highlighter-rouge">AStarPlanner</code> object.</p>

    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
</code></pre></div>    </div>
    <p>This is equivalent to writing:</p>
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>With this new and exciting knowledge, let’s define the open and closed lists. We will also add a hash function to support hashing of <code class="language-plaintext highlighter-rouge">Position</code> objects.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="p">...</span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>   

<span class="c1">// Custom hash function for std::pair&lt;int, int&gt;</span>
<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">hash2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">hash1</span> <span class="o">^</span> <span class="p">(</span><span class="n">hash2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">open_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span> <span class="n">closed_</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<hr>

<details>
  <summary>The current state of our code files.</summary>

  <p><code class="language-plaintext highlighter-rouge">astar.hpp</code> is done!</p>

  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Custom hash function for std::pair&lt;int, int&gt;</span>
<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">hash2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">hash1</span> <span class="o">^</span> <span class="p">(</span><span class="n">hash2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">SearchState</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchState</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// To accommodate the priority queue, which is a max heap by default.</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">rhs</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">SearchStatePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Planner</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    
<span class="nl">private:</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// Variables.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">open_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span> <span class="n">closed_</span><span class="p">;</span>
    
    <span class="c1">// Methods.</span>
    <span class="kt">int</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">);</span>

<span class="nl">public:</span>
    <span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">);</span>
    <span class="o">~</span><span class="n">AStarPlanner</span><span class="p">();</span>
    <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>  </div>

  <p>We still have some work on <code class="language-plaintext highlighter-rouge">astar.cpp</code>. This is its current state:</p>
  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>

<span class="n">AStarPlanner</span><span class="o">::</span><span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner constructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">AStarPlanner</span><span class="o">::~</span><span class="n">AStarPlanner</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner destructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>


<span class="n">Path</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Plan() called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">main.cpp</code> is done!</p>
  <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Position</span> <span class="n">start</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Position</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">planner</span><span class="o">-&gt;</span><span class="n">plan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>  </div>

</details>

<hr>

<h2 id="a-note-on-for-loops">A Note on <code class="language-plaintext highlighter-rouge">for</code> Loops</h2>
<p>In C++, there are a few ways to iterate over a collection of elements. The most common way is to use a one of the following <code class="language-plaintext highlighter-rouge">for</code> loops:</p>

<ul>
  <li>
<strong>Range-based <code class="language-plaintext highlighter-rouge">for</code> loop</strong>: This is a simple and clean way to iterate over a collection of elements. It is especially useful when you want to iterate over all elements in a collection. The syntax is as follows:
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>This will print each element of the vector <code class="language-plaintext highlighter-rouge">v</code> on a new line.</p>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">for</code> loop with iterators</strong>: An iterator is an object that points to an element in a collection. You can use iterators to access elements in a collection and iterate over them. The syntax for a <code class="language-plaintext highlighter-rouge">for</code> loop with iterators is as follows:
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">for</code> loop with index</strong>: If you need to access the index of an element in a collection, you can use a <code class="language-plaintext highlighter-rouge">for</code> loop with an index. The syntax is as follows:
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">for_each</code> algorithm</strong>: The <code class="language-plaintext highlighter-rouge">std::for_each</code> algorithm is a standard library algorithm that applies a function to each element in a collection. The syntax is as follows:
    <div class="language-cpp highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">});</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="implementing-a">Implementing A*</h1>

<p>We have all of our building blocks in place, so we can turn our attention to implementing the remaining functions to get the A* algorithm going!</p>

<p>Let’s start with the <code class="language-plaintext highlighter-rouge">computeHeuristic</code> function. This function will compute the manhattan distance between two points.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Manhattan distance.</span>
    <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">second</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Moving on, let’s implement <code class="language-plaintext highlighter-rouge">getSuccessors</code>. This takes in a <code class="language-plaintext highlighter-rouge">SearchState</code> and returns all the possible <code class="language-plaintext highlighter-rouge">SearchState</code>s that can be reached from that in one edge transition.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">successors</span><span class="p">;</span>

    <span class="c1">// Define the possible moves.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span> <span class="n">moves</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// For each move.</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">move</span> <span class="o">:</span> <span class="n">moves</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute the new position.</span>
        <span class="n">Position</span> <span class="n">pos_new</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">move</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="n">move</span><span class="p">.</span><span class="n">second</span><span class="p">};</span>

        <span class="c1">// Check if the new position is within the grid.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos_new</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos_new</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;=</span> <span class="n">grid_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">pos_new</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos_new</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;=</span> <span class="n">grid_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Check if the new position is an obstacle.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid_</span><span class="p">[</span><span class="n">pos_new</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos_new</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Create the new state.</span>
        <span class="k">auto</span> <span class="n">state_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">state_new</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos_new</span><span class="p">;</span>
        <span class="n">successors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">state_new</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">successors</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, let’s implement the <code class="language-plaintext highlighter-rouge">plan</code> function. This is the core of the A* algorithm.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Path</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Plan() called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Create the start state.</span>
    <span class="k">auto</span> <span class="n">startState</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">startState</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">+</span> <span class="n">startState</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// Add the start state to the open list.</span>
    <span class="n">open_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">startState</span><span class="p">);</span>

    <span class="c1">// While the open list is not empty.</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">open_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// Get the state with the minimum f value.</span>
        <span class="k">auto</span> <span class="n">currentState</span> <span class="o">=</span> <span class="n">open_</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">open_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="c1">// Check if the current state is the goal state.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">currentState</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Reconstruct the path.</span>
            <span class="n">Path</span> <span class="n">path</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">currentState</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">currentState</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>
                <span class="n">currentState</span> <span class="o">=</span> <span class="n">currentState</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">path</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Add the current state to the closed list.</span>
        <span class="n">closed_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">currentState</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>

        <span class="c1">// Get the successors of the current state.</span>
        <span class="k">auto</span> <span class="n">successors</span> <span class="o">=</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="n">currentState</span><span class="p">);</span>

        <span class="c1">// For each successor.</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">successor</span> <span class="o">:</span> <span class="n">successors</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If the successor is in the closed list, skip it.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">closed_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">successor</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="n">closed_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Compute the g, h, and f values.</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">=</span> <span class="n">currentState</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">successor</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">successor</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">+</span> <span class="n">successor</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentState</span><span class="p">;</span>

            <span class="c1">// Add the successor to the open list.</span>
            <span class="n">open_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">successor</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">{};</span>

<span class="p">}</span>
</code></pre></div></div>

<h1 id="what-we-did-not-talk-about">What we did not talk about</h1>
<ul>
  <li>Templates</li>
  <li>Namespaces</li>
  <li>Exceptions</li>
  <li>Assertions</li>
  <li>
<code class="language-plaintext highlighter-rouge">static</code> keyword</li>
  <li>
<code class="language-plaintext highlighter-rouge">friend</code> functions</li>
  <li>
<code class="language-plaintext highlighter-rouge">virtual</code> inheritance</li>
  <li>The Boost library</li>
  <li>The Standard Library: Algorithms</li>
  <li>Lambda functions</li>
  <li>And more and more :).</li>
</ul>

<h1 id="conclusion">Conclusion</h1>
<p>In this post we have briefly touched on many of the most used portions of C++. I hope that this will come in handy for some of you. Happy coding!</p>

<p><strong>Use of LLMs</strong>: GitHub Copilot was active when writing this post, so, as always when using LLMs, there is a plagiarism concern. Please let me know if this text looks similar to anything previously published and I’ll make sure to add the appropriate citations.</p>

    </div>
  </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;">
  <script>
    let giscusTheme = localStorage.getItem("theme");
    let giscusAttributes = {
        "src": "https://giscus.app/client.js",
        "data-repo": "alshedivat/al-folio",
        "data-repo-id": "MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==",
        "data-category": "Comments",
        "data-category-id": "DIC_kwDOA5PmLc4CTBt6",
        "data-mapping": "title",
        "data-strict": "1",
        "data-reactions-enabled": "1",
        "data-emit-metadata": "0",
        "data-input-position": "bottom",
        "data-theme": giscusTheme,
        "data-lang": "en",
        "crossorigin": "anonymous",
        "async": "",
    };


    let giscusScript = document.createElement("script");
    Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
    document.getElementById("giscus_thread").appendChild(giscusScript);
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a>
</noscript>
</div>
</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2024 Yorai  Shaoul. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.3/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-JY9P59WEMJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-JY9P59WEMJ');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
