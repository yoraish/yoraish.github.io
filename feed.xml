<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://yoraish.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yoraish.com/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-04-24T14:09:36+00:00</updated><id>https://yoraish.com/feed.xml</id><title type="html">blank</title><subtitle>A personal webpage with research and robots.
</subtitle><entry><title type="html">Shortest Path to Learn C++ (and A*)</title><link href="https://yoraish.com/blog/2024/learn-cpp-astar/" rel="alternate" type="text/html" title="Shortest Path to Learn C++ (and A*)" /><published>2024-10-27T14:14:00+00:00</published><updated>2024-10-27T14:14:00+00:00</updated><id>https://yoraish.com/blog/2024/learn-cpp-astar</id><content type="html" xml:base="https://yoraish.com/blog/2024/learn-cpp-astar/"><![CDATA[<h1 id="the-shortest-path-to-learn-c-and-a-a-brief-recap">The Shortest Path to Learn C++ (and A*): A Brief Recap</h1>

<blockquote>
  <p>Background: In the CMU class 16-782 Planning and Decision-Making in Robotics, students are assigned multiple homework assignments that involve implementing planning algorithms in C++. This post was originally made for the students in the class when I was a TA. Related code is available <a href="https://github.com/yoraish/shortest_path_to_cpp">here</a>.</p>
</blockquote>

<p>C++ has been (and will likely be for at least a bit) a central programming language in robotics. It is a powerful language that is flexible and (relatively) easy to write-in, while also being fast and efficient. This post
 comes to serve as a brief recap/summary/cheatsheet of some of the basics of C++ programming. We will be implementing the A* algorithm and discussing relevant C++ elements as we go.</p>

<p>From a high level, we will complete the following tasks today, and cover the following topics in the process:</p>

<ol>
  <li>Set up the directory structure for our planner project.
    <ul>
      <li><a href="#setting-up-common-directory-structure-in-c">Common directory structure in C++ projects.</a></li>
    </ul>
  </li>
  <li>Create the main entrypoint for our program.
    <ul>
      <li><a href="#the-main-function">The <code class="language-plaintext highlighter-rouge">main</code> function.</a></li>
    </ul>
  </li>
  <li>Set up a debugger in VSCode.
    <ul>
      <li><a href="#setting-up-a-debugger-in-vscode">Setting up a debugger in VSCode</a></li>
    </ul>
  </li>
  <li>Define the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct.
    <ul>
      <li>Discussing: <code class="language-plaintext highlighter-rouge">class</code>, <code class="language-plaintext highlighter-rouge">struct</code>, <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">protected</code>, <code class="language-plaintext highlighter-rouge">virtual</code>, and <code class="language-plaintext highlighter-rouge">override</code>.</li>
      <li><a href="#classes-structs-and-objects">Classes, structs, and objects.</a></li>
    </ul>
  </li>
  <li>Add member variables and functions to the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct. Discussing: the <code class="language-plaintext highlighter-rouge">plan</code>, <code class="language-plaintext highlighter-rouge">getSuccessors</code>, and <code class="language-plaintext highlighter-rouge">computeHeuristic</code> functions.
    <ul>
      <li>Discussing: passing by reference, default arguments, and operator overloading.</li>
      <li><a href="#functions">Functions</a></li>
    </ul>
  </li>
  <li>Add <code class="language-plaintext highlighter-rouge">open</code> and <code class="language-plaintext highlighter-rouge">closed</code> lists to the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class.
    <ul>
      <li>Discussing: <code class="language-plaintext highlighter-rouge">std::vector</code>, <code class="language-plaintext highlighter-rouge">std::pair</code>, <code class="language-plaintext highlighter-rouge">std::deque</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>, and <code class="language-plaintext highlighter-rouge">std::priority_queue</code>.</li>
      <li><a href="#the-standard-library-useful-objects">The standard library: useful objects.</a></li>
    </ul>
  </li>
  <li><a href="#implementing-a">Fill in the logic for the A* algorithm and helper methods.</a></li>
</ol>

<h2 id="setting-up-common-directory-structure-in-c">Setting Up: Common Directory Structure in C++</h2>

<p>When starting a new C++ project, it is common to have a directory structure like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.  
├── CMakeLists.txt
├── include
│   └── my_project
│       └── my_class_header_file.hpp
└── src
    ├── my_class_source_file.cpp
    └── main.cpp
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">include</code> directory is where we’ll put our header files. Header files are used to declare classes, functions, and variables that are used across our program. In our case, we will have a header file for our A* algorithm, which we will call <code class="language-plaintext highlighter-rouge">astar.hpp</code>. The <code class="language-plaintext highlighter-rouge">src</code> directory is where we put our source files. These usually contain the implementation of the classes and functions declared in the header files. In our case, we will have a source file for our A* algorithm, which we will call <code class="language-plaintext highlighter-rouge">astar.cpp</code>. <code class="language-plaintext highlighter-rouge">main.cpp</code> is the entrypoint file for our program. Everything that will run will begin there (this will hopefully become clearer soon). Now, since C++ is a compiled language, we need to tell the compiler how to build our project and turn it into an executable binary which we can run. This is where the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file comes in. This file contains information for building the project.</p>

<p>To start out then, create the following directory structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
├── CMakeLists.txt
├── include
│   └── shortest_path_to_cpp
│       └── astar.hpp
└── src
    ├── astar.cpp
    └── main.cpp
</code></pre></div></div>

<p>In what follows we will be keeping track of three files: <code class="language-plaintext highlighter-rouge">astar.hpp</code>, <code class="language-plaintext highlighter-rouge">astar.cpp</code>, and <code class="language-plaintext highlighter-rouge">main.cpp</code>.  They will start out empty and we will gradually fill them in.</p>

<hr />

<details>
  <summary>The current state of our code files.</summary>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
</code></pre></div>  </div>

</details>

<hr />

<h2 id="the-main-function">The <code class="language-plaintext highlighter-rouge">main</code> Function</h2>
<p>C++ programs start executing at the <code class="language-plaintext highlighter-rouge">main</code> function. Whatever this function does is what the program will do! Nothing fancy here. Normally, this function will create objects, call functions, and do whatever else is needed to run the program. In our case we will construct a grid here, create an A* planner object, and call its <code class="language-plaintext highlighter-rouge">plan</code> function.</p>

<p>The <code class="language-plaintext highlighter-rouge">main</code> function is the entry point of the program, and it has the following signature:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">argc</code> parameter is the number of arguments passed to the program, and <code class="language-plaintext highlighter-rouge">argv</code> is an array of strings containing the arguments. We won’t be using these in this post, but they are useful when you want to pass arguments to your program from the command line. It’s also possible to omit these parameters from the signature if you don’t need them.</p>

<p>Let’s create a simple example before we proceed. We’ll also use this as an opportunity for setting up the build system with CMake. Start by creating all the <code class="language-plaintext highlighter-rouge">.cpp</code> and <code class="language-plaintext highlighter-rouge">.hpp</code> files in the directory structure we discussed earlier. Now, for the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file, add the following:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>shortest_path_to_cpp<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 17<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span>include/shortest_path_to_cpp<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>planner src/main.cpp src/astar.cpp<span class="p">)</span>
</code></pre></div></div>
<p>To build the project, create a <code class="language-plaintext highlighter-rouge">build</code> directory in the root of the project and run the following commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>build
cmake .. <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Debug
make
</code></pre></div></div>
<p>Change the <code class="language-plaintext highlighter-rouge">Debug</code> to <code class="language-plaintext highlighter-rouge">Release</code> if you want to build a release version of the program. This will create an executable called <code class="language-plaintext highlighter-rouge">planner</code> in the <code class="language-plaintext highlighter-rouge">build</code> directory. You can run it by running <code class="language-plaintext highlighter-rouge">./planner</code> in the terminal.</p>

<hr />

<details>
  <summary>The current state of our code files.</summary>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

</details>

<hr />

<h2 id="setting-up-a-debugger-in-vscode">Setting Up a Debugger in VSCode</h2>
<p>One crucial tool for developing in C++ is a debugger. A debugger allows you to pause your program at any point and inspect the values of variables, the call stack, and more. This is incredibly useful when you are trying to figure out why your program is not working as expected. One popular way to set up a debugger is through VSCode, and today we will do just that. It is of course possible to use other editors/IDEs (e.g., CLion), or debug directly from the terminal (e.g., with <code class="language-plaintext highlighter-rouge">gdb</code>), but we will focus on VSCode since it is free and easy to set up. On top of helping us with debugging code, VSCode can also handle build tasks for us.</p>

<p>There are two main JSON files involved in setting up the debugger and build in VSCode: <code class="language-plaintext highlighter-rouge">launch.json</code> and <code class="language-plaintext highlighter-rouge">tasks.json</code>. The <code class="language-plaintext highlighter-rouge">launch.json</code> file contains the configuration for the debugger and the <code class="language-plaintext highlighter-rouge">tasks.json</code> file contains the configuration for the build tasks. 
Let’s create these files. The first step is to open your code in VSCode. To do that (via the terminal), navigate to the directory where your code is located and run <code class="language-plaintext highlighter-rouge">code .</code>. This will open the current directory in VSCode. Now, create a <code class="language-plaintext highlighter-rouge">.vscode</code> directory in the root of your project and create the <code class="language-plaintext highlighter-rouge">launch.json</code> and <code class="language-plaintext highlighter-rouge">tasks.json</code> files in it. This can be done automatically via the GUI as well. Populate the <code class="language-plaintext highlighter-rouge">launch.json</code> file with the following:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Planner Debug"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppdbg"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/build/planner"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
            </span><span class="nl">"stopAtEntry"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"environment"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
            </span><span class="nl">"externalConsole"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="nl">"MIMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"setupCommands"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="p">{</span><span class="w">
                    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enable pretty-printing for gdb"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-enable-pretty-printing"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"preLaunchTask"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>And populate the <code class="language-plaintext highlighter-rouge">tasks.json</code> file with the following:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cmake"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"--build"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/build"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"--config"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"Debug"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"$gcc"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>In the VSCode GUI we can now go to the debug tab (ctrl + shift + D in Ubuntu) and find our <code class="language-plaintext highlighter-rouge">Planner Debug</code> configuration.
Clicking on the play button runs our program in debug mode  (make sure that your build files were created with the <code class="language-plaintext highlighter-rouge">Debug</code> CMake flag). Allow me to repeat – if this does not work <em>make sure</em> that your code was built in <code class="language-plaintext highlighter-rouge">Debug</code> mode. Delete your <code class="language-plaintext highlighter-rouge">build</code> directory and run <code class="language-plaintext highlighter-rouge">cmake .. -DCMAKE_BUILD_TYPE=Debug</code> again.</p>

<p>We can play around with the debugger: create some variables and add some breakpoints in <code class="language-plaintext highlighter-rouge">main.cpp</code> to see how it works.</p>

<hr />

<details>
  <summary>The current state of our code files.</summary>

  <p>Let’s also add a header guard to our <code class="language-plaintext highlighter-rouge">astar.hpp</code> file to prevent multiple inclusions of the file. This may become clearer later.</p>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#pragma once
</span></code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

</details>

<hr />

<h2 id="classes-structs-and-objects">Classes, Structs, and Objects</h2>
<p>Let’s begin implementing our A* planning algorithm! In this section we’ll start setting up the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct which we will us in our implementation and also discuss classes and structs in C++ more generally.</p>

<h3 id="classes"><code class="language-plaintext highlighter-rouge">class</code>es</h3>
<p>A <code class="language-plaintext highlighter-rouge">class</code> is a user-defined data type that groups related data and functions together. Let’s discuss a few features of classes and them put them to work in our A* planner implementation.</p>

<ul>
  <li>
    <p><strong>Member Variables</strong>:
Member variables are variables that belong to a class. They are declared inside the class definition and can be accessed by any member function of the class. A member variable we care about in A* is the grid we are planning on. We will store this in the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class under the name <code class="language-plaintext highlighter-rouge">grid_</code>. The trailing underscore is a common naming convention for <a href="#access-modifiers"><code class="language-plaintext highlighter-rouge">private</code></a> member variables in C++.</p>
  </li>
  <li>
    <p><strong>Member Functions</strong>:
Similar to member variables, member functions (also called class methods) are functions that are defined in the class and can access any member of the class. They are used to perform operations on the data stored in the class with potential extra inputs. Our A* planner will have a member function called <code class="language-plaintext highlighter-rouge">plan</code> that will take a start and goal position and plan a path between them.</p>
  </li>
  <li>
    <p><strong>Constructors and Destructors</strong>:
Constructors are special member functions that are called when an object of a class is created. They are used to initialize the object’s member variables. Destructors are are similar, and are called when an object is destroyed. They are used to clean up resources used by the object. C++ provides a default constructor and destructor if you don’t define one yourself. We will store the planning grid in the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class in the constructor. We will do this in an initialization list, which is a list of member variables to initialize in the constructor. This is more efficient than initializing the variables in the constructor body.</p>
  </li>
  <li>
    <p><strong>Access Modifiers</strong>:   Access modifiers are keywords that control the visibility of class members. There are three access modifiers in C++: <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, and <code class="language-plaintext highlighter-rouge">protected</code>. Members declared as <code class="language-plaintext highlighter-rouge">public</code> can be accessed from outside the class, members declared as <code class="language-plaintext highlighter-rouge">private</code> can only be accessed from within the class, and members declared as <code class="language-plaintext highlighter-rouge">protected</code> can be accessed from within the class and by derived classes (see the next section for more on this).</p>
  </li>
  <li>
    <p><strong>Inheritance</strong>:
Inheritance is a feature of C++ that allows you to create a new class that is based on an existing class. Inherited classes (also called derived classes) include all the public and protected members of the base class (also called the parent class). This allows you to reuse code and create a hierarchy of classes. In our implementation, we will create a <code class="language-plaintext highlighter-rouge">Planner</code> base class and then create a derived class for the A* planner. Per the definition of the base class, all derived-class planners will be required to implement a <code class="language-plaintext highlighter-rouge">plan</code> function.</p>
  </li>
</ul>

<h4 id="a-planner-class">A* Planner Class</h4>
<p>Alright, less talk more do. Let’s get going with the implementation. 
We’ll use a class to represent a planning algorithm in our program, and a derived class for our A* planner. The parent class will be <em>abstract</em>, meaning that it will have at least one <em>pure virtual function</em>—a function with no implementation marked with (<code class="language-plaintext highlighter-rouge">=0</code>). This is often done to dictate the structure of derived classes and force them to implement certain functions. In our case, we will have a abstract <code class="language-plaintext highlighter-rouge">Planner</code> base class that will have the pure virtual function <code class="language-plaintext highlighter-rouge">plan</code>, The derived A* planner class will implement this function.</p>

<p>We will also add some private methods, <code class="language-plaintext highlighter-rouge">computeHeuristic</code>, <code class="language-plaintext highlighter-rouge">expand</code>, and <code class="language-plaintext highlighter-rouge">getSuccessors</code>, to help with the planning process. As a matter of convenience, we’ll create aliases to some types (i.e., shorter names to types that are long to type out and used frequently). For example, we will create an alias to <code class="language-plaintext highlighter-rouge">std::pair&lt;int, int&gt;</code>, which we use to store robot position values, and simply call it <code class="language-plaintext highlighter-rouge">Position</code>. This will make our code more readable and easier to understand. We do this with the keyword <code class="language-plaintext highlighter-rouge">using</code> (or the older <code class="language-plaintext highlighter-rouge">typedef</code>).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="cp">#pragma once
</span><span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Planner</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>

    <span class="c1">// TODO: computeHeuristic.</span>
    <span class="c1">// TODO: getSuccessors.</span>
    <span class="c1">// TODO: expand.</span>
<span class="nl">public:</span>
    <span class="c1">// Member functions.</span>
    <span class="n">Planner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="c1">// Member variables.</span>
    <span class="c1">// TODO: Open list, </span>
    <span class="c1">// TODO: closed list,</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="structs"><code class="language-plaintext highlighter-rouge">struct</code>s</h3>
<p>A <code class="language-plaintext highlighter-rouge">struct</code> is a data type identical to a class, with the exception that its members are public by default (as opposed to private in classes). They are used to group related data together. In our implementation, we will use a <code class="language-plaintext highlighter-rouge">struct</code> to represent a state in the search.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="k">struct</span> <span class="nc">SearchState</span>
<span class="p">{</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The state of our code now, with the <code class="language-plaintext highlighter-rouge">Planner</code> and <code class="language-plaintext highlighter-rouge">AStarPlanner</code> classes and the <code class="language-plaintext highlighter-rouge">SearchState</code> struct defined, is as follows:</p>

<hr />

<details>
  <summary>The current state of our code files.</summary>

  <p>Let’s also add a header guard to our <code class="language-plaintext highlighter-rouge">astar.hpp</code> file to prevent multiple inclusions of the file. This may become clearer later.</p>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="cp">#pragma once
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SearchState</span>
<span class="p">{</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Planner</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// Variables.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>
    <span class="c1">// TODO: open_;</span>
    <span class="c1">// TODO: closed_;</span>
    
    <span class="c1">// Methods.</span>
    <span class="c1">// TODO: computeHeuristic.</span>
    <span class="c1">// TODO: getSuccessors.</span>
<span class="nl">public:</span>
    <span class="c1">// Member functions.</span>
    <span class="n">Planner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
<span class="cp"># include &lt;astar.hpp&gt;
</span>
<span class="n">Planner</span><span class="o">::</span><span class="n">Planner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Implement the A* algorithm here.</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Your code here.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Welcome to Planning with Friends!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

</details>

<hr />

<h2 id="functions">Functions</h2>
<p>As we get ready to define the member functions of our A* algorithm, it’s worth mentioning some features of functions in C++.</p>

<ul>
  <li><strong>Overloading</strong>: C++ allows you to define multiple functions with the same name but different parameters. This is called function overloading. It is convenient when you want to perform the same operation on different types of data.
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">float</span> <span class="nf">add</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Default Arguments</strong>: You can provide default values for function parameters. If a value is not provided when the function is called, the default value will be used.
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Operator Overloading</strong>: C++ allows you to redefine the behavior of operators for user-defined types. This is called operator overloading. For example, in our implementation we will define the <code class="language-plaintext highlighter-rouge">&lt;</code> operator for the <code class="language-plaintext highlighter-rouge">SearchState</code> struct to compare states based on their <code class="language-plaintext highlighter-rouge">f</code> values. (We negate the f-values to make the priority queue, which is normally a max-heap, a min-heap.)
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchState</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">other</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>Note that the <code class="language-plaintext highlighter-rouge">const</code> keyword at the end of the function declaration means that the function does not modify the object it is called on. The “const reference” <code class="language-plaintext highlighter-rouge">other</code> is explained next.</p>
  </li>
  <li>
    <p><strong>Passing Arguments</strong>: function arguments can be passed in a few ways: by value, by reference, and by pointer.</p>

    <ul>
      <li><strong>Pass by value</strong>: The default is by value, which means that a copy of the object is passed to the function.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v is copied, and the copy is modified.</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li><strong>Pass by reference</strong>: When you pass a variable by reference, you are passing the memory address of the variable instead of the value. This is more efficient than passing by value, as the entire object is not copied.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v is modified directly.</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
        <p>A common use case for passing by reference is when you want to modify the object passed to the function. Or in other words, if you want to “return more than one value” from a function. An example for this is below, where both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are modified.</p>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">assignValues</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <p>A version of passing by reference is is <strong>passing by <code class="language-plaintext highlighter-rouge">const</code> reference</strong>, which means that the object cannot be modified. This is useful when we want to use the information stored in some object without changing it.</p>
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v cannot be modified.</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// This will not compile.</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// This is fine.</span>
  <span class="p">}</span>

</code></pre></div>        </div>
      </li>
      <li><strong>Pass by pointer</strong>: A pointer is a variable that stores the memory address of another variable. When you pass a variable by pointer, you are passing the memory address of the variable. This is similar to passing by reference, but you need to dereference the pointer to access the object.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="c1">// v is modified directly.</span>
      <span class="n">v</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p>Let’s put this to work by adding the definitions (not implementation yet) of the various functions we will need in our A* planner. We have already done the <code class="language-plaintext highlighter-rouge">plan</code> function, so let us now continue with the <code class="language-plaintext highlighter-rouge">computeHeuristic</code> and <code class="language-plaintext highlighter-rouge">getSuccessors</code> functions.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="p">...</span>
    <span class="kt">int</span> <span class="nf">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>
<h3 id="objects">Objects</h3>
<p>An object is an instance of a class or struct. In our code we’ll create, for example, an instance of the <code class="language-plaintext highlighter-rouge">AStarPlanner</code> class and call its <code class="language-plaintext highlighter-rouge">plan</code> function. Let’s set up the <code class="language-plaintext highlighter-rouge">main</code> function to create a grid and call the planner.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="p">};</span>

    <span class="n">AStarPlanner</span> <span class="nf">planner</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">Position</span> <span class="n">start</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Position</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">planner</span><span class="p">.</span><span class="n">plan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is also possible to directly create a pointer to an object using the <code class="language-plaintext highlighter-rouge">new</code> keyword or <code class="language-plaintext highlighter-rouge">std::make_shared</code> function. This is useful when you want to create an object that will outlive the current scope. In our case, we will create shared pointers to <code class="language-plaintext highlighter-rouge">SearchState</code> objects. We’ll talk more about pointers in the next section.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<p>In fact, since we will be making use of this pointer quite a bit, we’ll create an alias for it to make our code more readable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">SearchStatePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<details>
  <summary>The current state of our code files.</summary>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SearchState</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchState</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// To accommodate the priority queue, which is a max heap by default.</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">rhs</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">SearchStatePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Planner</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    
<span class="nl">private:</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// Variables.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>
    <span class="c1">// TODO: open_;</span>
    <span class="c1">// TODO: closed_;</span>
    
    <span class="c1">// Methods.</span>
    <span class="kt">int</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">);</span>

<span class="nl">public:</span>
    <span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">);</span>
    <span class="o">~</span><span class="n">AStarPlanner</span><span class="p">();</span>
    <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>

<span class="n">AStarPlanner</span><span class="o">::</span><span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner constructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">AStarPlanner</span><span class="o">::~</span><span class="n">AStarPlanner</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner destructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>


<span class="n">Path</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Plan() called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Position</span> <span class="n">start</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Position</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">planner</span><span class="o">-&gt;</span><span class="n">plan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>  </div>

</details>

<hr />

<h2 id="the-standard-library-useful-objects">The Standard Library: Useful Objects</h2>
<p>We are almost ready to implement the logic of the A* algorithm. We are only missing the OPEN and CLOSED lists. Conceptually, there are various data structures that we could use to achieve different goals. Between lists, sets, heaps, and trees, we have a lot of options.</p>

<ul>
  <li>
    <p><strong>Lists</strong> are like simple containers – they hold elements nicely, but are not ideal if we want to repeatedly sort their elements or check if elements are present.</p>
  </li>
  <li>
    <p><strong>Sets</strong> are unordered but have fast lookup times. These are often implemented as hash tables.</p>
  </li>
  <li>
    <p><strong>Maps</strong> are similar to sets, but they store key-value pairs. Getting the value associated with a key is done in constant time and checking if a key is in the map is also done in constant time.</p>
  </li>
  <li>
    <p><strong>Heaps</strong> allow us to access the element with the highest priority in constant time and insert new elements in logarithmic time.</p>
  </li>
  <li>
    <p><strong>Trees</strong> allow for fast (but not constant time) search while preserving order.</p>
  </li>
</ul>

<p>This section will discuss the C++ counterparts for these data structures and how we can use them in our implementation. Specifically, we will cover the relevant objects from the C++ standard library</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::vector</code></strong>:
A vector is a dynamic array that can grow and shrink in size. It is conceptually similar to a list that can change its size at runtime. In our implementation, we have already used vectors to represent the grid and store the path. Another use for a <code class="language-plaintext highlighter-rouge">vector</code> can be the queue of a depth-first search, for example. Searching through a vector can be done with the <code class="language-plaintext highlighter-rouge">std::find</code> function, which returns an <a href="#what-we-did-not-talk-about">iterator</a> to the element if it is found, or the end of the vector if it is not found.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Element found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::deque</code></strong>: A deque (double-ended queue) is a data structure that allows insertion and deletion at both ends. It is similar to a vector, but it is more efficient when elements are added or removed from the front of the container. This can be used as the queue in a breadth-first search, for example. Checking if an element is in a deque can be done in linear time.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">d</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Element found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>Adding and removing elements from the back and front of a deque is done like this:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="n">d</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    
  <span class="n">d</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="n">d</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::pair</code></strong> A pair is a simple container that can hold two values. It is useful when you need to return two values from a function or store two values together. In our implementation, we use pairs to represent positions on the grid.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::unordered_set</code></strong>: An unordered set is a data structure that stores unique elements in no particular order. Under the hood, it is a hash table. If hashing custom elements, you will need to provide a hash function.
In our implementation, we will use an unordered set to store the closed list of states.
Checking if an element is in an unordered set can be done in constant time.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Element found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::unordered_map</code></strong>: An unordered map is a data structure that stores key-value pairs in no particular order. If hashing custom elements, you will need to provide a hash function. A similar <code class="language-plaintext highlighter-rouge">find</code> method to the unordered set can be used to check if a key is in the map.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::priority_queue</code></strong>:
A priority queue is a data structure that stores elements in a sorted order. When elements are added to the queue, they are placed in the correct position based on their priority. The element with the highest priority is at the front of the queue. In our implementation, we will use a priority queue to store the open list of states to explore. The priority queue will make use of the <code class="language-plaintext highlighter-rouge">&lt;</code> operator we defined for the <code class="language-plaintext highlighter-rouge">SearchState</code> struct to order the states based on their <code class="language-plaintext highlighter-rouge">f</code> values.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">open_list</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>We can access the element with the highest priority in constant time with the <code class="language-plaintext highlighter-rouge">top</code> method. We can add elements to the queue with the <code class="language-plaintext highlighter-rouge">push</code> method and remove elements with the <code class="language-plaintext highlighter-rouge">pop</code> method.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SearchStatePtr</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">state</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">open_list</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="n">open_list</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>We have already seen some pointers in this post, but we will also introduce a few more objects from the standard library that are useful in this context.</p>

<ul>
  <li>
    <p><strong>Pointers and Smart Pointers</strong>:
C++ has introduce, since C++11, a class of objects called smart pointers. These are objects that manage the memory of a pointer automatically. A <code class="language-plaintext highlighter-rouge">shared_ptr</code> is a smart pointer that can be shared among multiple objects. It keeps track of how many objects are pointing to the same memory location and deletes the memory when the last object is destroyed. In our implementation, we will use shared pointers to manage the memory of our search states. It is worth looking at a quick example of how shared pointers can be safer to work with than raw pointers.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Using raw pointers</span>
  <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">SearchState</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SearchState</span><span class="p">();</span>
      <span class="c1">// Do something with state</span>
      <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Using shared pointers</span>
  <span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
      <span class="c1">// Do something with state</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>In the first function, if we were to forget deleting the <code class="language-plaintext highlighter-rouge">state</code> object, we would have a memory leak. In the second function, the <code class="language-plaintext highlighter-rouge">state</code> object will be automatically deleted when it goes out of scope (i.e., when the function ends).</p>

    <p>For any pointer, the actual object it points to can be retrieved by <em>dereferencing</em> the pointer. This is done with the <code class="language-plaintext highlighter-rouge">*</code> operator. For example, to access the <code class="language-plaintext highlighter-rouge">f</code> value of a <code class="language-plaintext highlighter-rouge">SearchState</code> object pointed to by a shared pointer, we would do the following:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SearchStatePtr</span> <span class="n">state</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">state</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">SearchState</span> <span class="n">s</span> <span class="o">=</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>The <code class="language-plaintext highlighter-rouge">auto</code> Keyword</strong>: The <code class="language-plaintext highlighter-rouge">auto</code> keyword is used to automatically deduce the type of a variable. This can be useful when the type of the variable is long or complex (but clear from context). In our implementation, we use <code class="language-plaintext highlighter-rouge">auto</code> to create a shared pointer to an <code class="language-plaintext highlighter-rouge">AStarPlanner</code> object.</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">auto</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
</code></pre></div>    </div>
    <p>This is equivalent to writing:</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>With this new and exciting knowledge, let’s define the open and closed lists. We will also add a hash function to support hashing of <code class="language-plaintext highlighter-rouge">Position</code> objects.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="p">...</span>
<span class="cp">#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>   

<span class="c1">// Custom hash function for std::pair&lt;int, int&gt;</span>
<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">hash2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">hash1</span> <span class="o">^</span> <span class="p">(</span><span class="n">hash2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="p">...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">open_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span> <span class="n">closed_</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<hr />

<details>
  <summary>The current state of our code files.</summary>

  <p><code class="language-plaintext highlighter-rouge">astar.hpp</code> is done!</p>

  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Custom hash function for std::pair&lt;int, int&gt;</span>
<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">hash1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">hash2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">hash1</span> <span class="o">^</span> <span class="p">(</span><span class="n">hash2</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">SearchState</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Position</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchState</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// To accommodate the priority queue, which is a max heap by default.</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">f</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">rhs</span><span class="p">.</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">SearchStatePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Planner</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    
<span class="nl">private:</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AStarPlanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Planner</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// Variables.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">open_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span> <span class="n">closed_</span><span class="p">;</span>
    
    <span class="c1">// Methods.</span>
    <span class="kt">int</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">);</span>

<span class="nl">public:</span>
    <span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">);</span>
    <span class="o">~</span><span class="n">AStarPlanner</span><span class="p">();</span>
    <span class="n">Path</span> <span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>  </div>

  <p>We still have some work on <code class="language-plaintext highlighter-rouge">astar.cpp</code>. This is its current state:</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// astar.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>

<span class="n">AStarPlanner</span><span class="o">::</span><span class="n">AStarPlanner</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="o">:</span> <span class="n">grid_</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner constructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">AStarPlanner</span><span class="o">::~</span><span class="n">AStarPlanner</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AStarPlanner destructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>


<span class="n">Path</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Plan() called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">main.cpp</code> is done!</p>
  <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;planner.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Position</span> <span class="n">start</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">Position</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="n">planner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AStarPlanner</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">planner</span><span class="o">-&gt;</span><span class="n">plan</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>  </div>

</details>

<hr />

<h2 id="a-note-on-for-loops">A Note on <code class="language-plaintext highlighter-rouge">for</code> Loops</h2>
<p>In C++, there are a few ways to iterate over a collection of elements. The most common way is to use a one of the following <code class="language-plaintext highlighter-rouge">for</code> loops:</p>

<ul>
  <li><strong>Range-based <code class="language-plaintext highlighter-rouge">for</code> loop</strong>: This is a simple and clean way to iterate over a collection of elements. It is especially useful when you want to iterate over all elements in a collection. The syntax is as follows:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
    <p>This will print each element of the vector <code class="language-plaintext highlighter-rouge">v</code> on a new line.</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">for</code> loop with iterators</strong>: An iterator is an object that points to an element in a collection. You can use iterators to access elements in a collection and iterate over them. The syntax for a <code class="language-plaintext highlighter-rouge">for</code> loop with iterators is as follows:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">for</code> loop with index</strong>: If you need to access the index of an element in a collection, you can use a <code class="language-plaintext highlighter-rouge">for</code> loop with an index. The syntax is as follows:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">for_each</code> algorithm</strong>: The <code class="language-plaintext highlighter-rouge">std::for_each</code> algorithm is a standard library algorithm that applies a function to each element in a collection. The syntax is as follows:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">});</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="implementing-a">Implementing A*</h1>

<p>We have all of our building blocks in place, so we can turn our attention to implementing the remaining functions to get the A* algorithm going!</p>

<p>Let’s start with the <code class="language-plaintext highlighter-rouge">computeHeuristic</code> function. This function will compute the manhattan distance between two points.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">computeHeuristic</span><span class="p">(</span><span class="n">Position</span> <span class="n">a</span><span class="p">,</span> <span class="n">Position</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Manhattan distance.</span>
    <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">second</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Moving on, let’s implement <code class="language-plaintext highlighter-rouge">getSuccessors</code>. This takes in a <code class="language-plaintext highlighter-rouge">SearchState</code> and returns all the possible <code class="language-plaintext highlighter-rouge">SearchState</code>s that can be reached from that in one edge transition.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">getSuccessors</span><span class="p">(</span><span class="k">const</span> <span class="n">SearchStatePtr</span><span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchStatePtr</span><span class="o">&gt;</span> <span class="n">successors</span><span class="p">;</span>

    <span class="c1">// Define the possible moves.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span> <span class="n">moves</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// For each move.</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">move</span> <span class="o">:</span> <span class="n">moves</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute the new position.</span>
        <span class="n">Position</span> <span class="n">pos_new</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">move</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="n">move</span><span class="p">.</span><span class="n">second</span><span class="p">};</span>

        <span class="c1">// Check if the new position is within the grid.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos_new</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos_new</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;=</span> <span class="n">grid_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">pos_new</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos_new</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;=</span> <span class="n">grid_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Check if the new position is an obstacle.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid_</span><span class="p">[</span><span class="n">pos_new</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos_new</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Create the new state.</span>
        <span class="k">auto</span> <span class="n">state_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">state_new</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos_new</span><span class="p">;</span>
        <span class="n">successors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">state_new</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">successors</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, let’s implement the <code class="language-plaintext highlighter-rouge">plan</code> function. This is the core of the A* algorithm.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Path</span> <span class="n">AStarPlanner</span><span class="o">::</span><span class="n">plan</span><span class="p">(</span><span class="n">Position</span> <span class="n">start</span><span class="p">,</span> <span class="n">Position</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Plan() called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Create the start state.</span>
    <span class="k">auto</span> <span class="n">startState</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SearchState</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">startState</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">+</span> <span class="n">startState</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">startState</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="c1">// Add the start state to the open list.</span>
    <span class="n">open_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">startState</span><span class="p">);</span>

    <span class="c1">// While the open list is not empty.</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">open_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// Get the state with the minimum f value.</span>
        <span class="k">auto</span> <span class="n">currentState</span> <span class="o">=</span> <span class="n">open_</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">open_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="c1">// Check if the current state is the goal state.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">currentState</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Reconstruct the path.</span>
            <span class="n">Path</span> <span class="n">path</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">currentState</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">currentState</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>
                <span class="n">currentState</span> <span class="o">=</span> <span class="n">currentState</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">path</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Add the current state to the closed list.</span>
        <span class="n">closed_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">currentState</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>

        <span class="c1">// Get the successors of the current state.</span>
        <span class="k">auto</span> <span class="n">successors</span> <span class="o">=</span> <span class="n">getSuccessors</span><span class="p">(</span><span class="n">currentState</span><span class="p">);</span>

        <span class="c1">// For each successor.</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">successor</span> <span class="o">:</span> <span class="n">successors</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If the successor is in the closed list, skip it.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">closed_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">successor</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="n">closed_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Compute the g, h, and f values.</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">=</span> <span class="n">currentState</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">computeHeuristic</span><span class="p">(</span><span class="n">successor</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">f</span> <span class="o">=</span> <span class="n">successor</span><span class="o">-&gt;</span><span class="n">g</span> <span class="o">+</span> <span class="n">successor</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>
            <span class="n">successor</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">currentState</span><span class="p">;</span>

            <span class="c1">// Add the successor to the open list.</span>
            <span class="n">open_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">successor</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">{};</span>

<span class="p">}</span>
</code></pre></div></div>

<h1 id="what-we-did-not-talk-about">What we did not talk about</h1>
<ul>
  <li>Templates</li>
  <li>Namespaces</li>
  <li>Exceptions</li>
  <li>Assertions</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> keyword</li>
  <li><code class="language-plaintext highlighter-rouge">friend</code> functions</li>
  <li><code class="language-plaintext highlighter-rouge">virtual</code> inheritance</li>
  <li>The Boost library</li>
  <li>The Standard Library: Algorithms</li>
  <li>Lambda functions</li>
  <li>And more and more :).</li>
</ul>

<h1 id="conclusion">Conclusion</h1>
<p>In this post we have briefly touched on many of the most used portions of C++. I hope that this will come in handy for some of you. Happy coding!</p>

<p><strong>Use of LLMs</strong>: GitHub Copilot was active when writing this post, so, as always when using LLMs, there is a plagiarism concern. Please let me know if this text looks similar to anything previously published and I’ll make sure to add the appropriate citations.</p>]]></content><author><name></name></author><category term="industry" /><summary type="html"><![CDATA[A brief introduction to C++ by implementing the A* algorithm.]]></summary></entry><entry><title type="html">Robotics Engineer, A Recipe (and how to prepare for interviews)</title><link href="https://yoraish.com/blog/2023/robotics-map/" rel="alternate" type="text/html" title="Robotics Engineer, A Recipe (and how to prepare for interviews)" /><published>2023-08-19T14:14:00+00:00</published><updated>2023-08-19T14:14:00+00:00</updated><id>https://yoraish.com/blog/2023/robotics-map</id><content type="html" xml:base="https://yoraish.com/blog/2023/robotics-map/"><![CDATA[<p>I feel extremely fortunate to have had the chance to work with multiple robotics engineering teams in the past few years. Throughout the process of applying and interviewing for these positions, and of course developing and implementing algorithms in the real world, I have gotten extensive advice from my mentors and colleagues. After some time I have begun to see trends in these pieces of advice, and I thought it could be useful to to write them down and share them with, well, with you.</p>

<h3 id="if-you-do-not-want-to-read-this-but-you-do-want-to-do-robotics-engineering-then">If you do not want to read this, but you do want to do robotics engineering, then</h3>
<p>Then just choose a robotics project, and go make it. You’ll learn a ton and hopefully have some fun too. I feel like if you have the time and motivation then there is no better way to get a deep understanding of robotics systems other than creating them.</p>

<h3 id="if-you-do-though">If you do, though</h3>

<p>Then let’s get into more details. I have divided this post into two parts.</p>

<p>The first part is the <strong>what</strong>. This is the <em>stuff</em>  that would hopefully give you a sufficiently broad view of a robotic system. Besides needing this kind of perspective, in my opinion, to build robust systems, interviewers will also probably want you to demonstrate that you have it in a basic level. The list below could be overwhelming – remember tht each role would require knowledge of a different subset of topics, so pick and choose what you think is relevant for you :).</p>

<p>The second part is the <strong>how</strong>. This will be a collection of tips and tricks that I have found useful in the past when I was being interviewed.</p>

<p>None of the lists to follow are comprehensive. Hopefully they could point you in the right direction, though!</p>

<h2 id="the-what-algorithms-and-concepts">The What: Algorithms and Concepts</h2>

<p>I like seeing the different topics that comprise the field of robotics as a hierarchy. Going from the least “abstract” to the most, I tend to put topics in the following high-level buckets:</p>

<ul>
  <li><strong>Controls</strong>: what voltage should motors receive in order for a robot to track some predefined trajectory. What are common methods for using sensory feedback and reacting to it?</li>
  <li><strong>Planning</strong>: how can we find a sequence of actions that will take a robot from point A to point B. How can we do this in a way that is dynamically-sound, and robust to uncertainty and to the presence of other agents and obstacles?</li>
  <li><strong>Localization and Mapping</strong>: how can we build a map of the environment and localize a robot within it. With this information, we could plan paths from a start location on a map to a goal location on the map and control the robot to follow it.</li>
  <li><strong>Learning, Perception, and Higher Level Scene Understanding</strong>: robots can be seen as data-collection machines. Can robots learn to improve themselves from the data they collect? Yes, they can. And learning algorithms can be applied to improve perception, planning, and control algorithms (and more!).</li>
</ul>

<p>Each of these topics is extremely broad. Here are some subtopics and algorithms you could familiarize yourself with to get a grasp of each of these topics. Their order is somewhat arbitrary, I see this as a bit of a cookbook recipe and encourage you to tweak it as you need!</p>

<ul>
  <li><strong>Controls</strong>
    <ul>
      <li>PID</li>
      <li>Pure Pursuit</li>
      <li>State space and state space models</li>
      <li>Model predictive control</li>
      <li>Trajectory optimization</li>
    </ul>
  </li>
  <li><strong>Planning</strong>
    <ul>
      <li>Graph based methods:
        <ul>
          <li>Dijkstra’s Algorithm</li>
          <li>A*</li>
          <li>BFS</li>
          <li>DFS</li>
          <li>ARA*, MHA*, and many others</li>
        </ul>
      </li>
      <li>Sampling based methods:
        <ul>
          <li>RRT (Rapidly exploring Random Trees)</li>
          <li>Bidirectional RRT</li>
          <li>RRT*</li>
          <li>RRG (Rapidly exploring Random Graphs)</li>
          <li>PRM (probabilistic roadmaps)</li>
          <li>PRM*</li>
        </ul>
      </li>
      <li>And if you are cool, multi agent planning algorithms (the following are graph-based)
        <ul>
          <li>Conflict Based Search (CBS)</li>
          <li>ECBS (Enhanced CBS)</li>
          <li>MAPF-LNS (Multi-agent path finding with large neighborhood search)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Localization (and state estimation)</strong>
    <ul>
      <li>Different map representations
        <ul>
          <li>grid occupancy maps, voxel grids, graphs of convex sets, meshes, etc.</li>
        </ul>
      </li>
      <li>Scan matching (2D and 3D pointclouds, often using ICP with laser scans)</li>
      <li>ICP (Iterative Closest Point)</li>
      <li>Ray tracing</li>
      <li>Particle filter</li>
      <li><strong>Kalman Filters</strong> (and the extended Kalman filter for extra credit)</li>
      <li>Fundamentals of odometry</li>
    </ul>
  </li>
  <li><strong>Mapping</strong>
    <ul>
      <li>SLAM (includes localization, of course). Knowledge of the two components of general SLAM systems: motion model and sensor model.</li>
      <li>Online SLAM (Full-SLAM) and offline slam.</li>
      <li>Extra: pose-graph optimization, KF-based SLAM vs Smoothing based SLAM. Know of semantic SLAM, visual slam, and more traditional SLAM. Hector-SLAM, and Cartographer.</li>
      <li>Octomapping/gmapping.</li>
    </ul>
  </li>
  <li><strong>Learning, Perception, and Higher Level Scene Understanding</strong>
    <ul>
      <li>Neural Networks
        <ul>
          <li>Convolutional neural networks</li>
          <li>Activation layers</li>
          <li>Loss functions</li>
          <li>Backpropagation</li>
          <li>Gradient descent</li>
          <li>Reinforcement learning, supervised learning, semi-supervised learning, unsupervised learning</li>
          <li>And to be trendy, large language models and transformers.</li>
        </ul>
      </li>
      <li>Perception and learning
        <ul>
          <li>3D geometry
            <ul>
              <li>Shape estimation</li>
              <li>Place recognition</li>
              <li>Manipulation example: grasp computation</li>
            </ul>
          </li>
          <li>Computer vision
            <ul>
              <li>Segmentation</li>
              <li>Detection</li>
              <li>Visual odometry</li>
              <li>Optical flow,</li>
              <li>Tracking)</li>
              <li>Camera calibration (intrinsics, extrinsics)</li>
              <li>Epipolar geometry (essential matrix, fundamental matrix.)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>We must also remember our fundamentals:</p>

<ul>
  <li>A tad ot <strong>physics</strong>:
    <ul>
      <li>Kinematics</li>
      <li>Free-fall mechanics (accelerations)</li>
      <li>\(F = ma\) (sounds silly but this is important for going between talking in terms of velocity derivatives and energy).</li>
      <li>Forward and inverse kinematics (mostly for manipulation).</li>
    </ul>
  </li>
  <li>
    <p>A bit of <strong>math</strong>:</p>

    <ul>
      <li>Reference frames and rigid transformations</li>
      <li>Pseudo-inverse</li>
      <li>SVD</li>
      <li>Eigenvalues and eigenvectors</li>
      <li>Optimization</li>
    </ul>
  </li>
</ul>

<p>If you know all of that, you’ll be a… good theoretical researcher. Undoubtedly, you’ll be able to talk to many folks in the field and be up to speed with their work. However, to transform yourself to a great <em>engineer</em>, you’ll also need some hands-on experience with the common tools teams use to apply all of these theoretical concepts in real-world systems.</p>

<h2 id="the-what-software-tools">The What: Software Tools</h2>

<p>Let’s face it. Most robotics engineers are specialized software engineers. We (they) spend much of our (their) time coding in a collaborative environment. Besides common software engineering tools, there are a few tools that are specific to robotics that you may benefit from being familiar with. Here are some of them (alongside the common tools):</p>

<ul>
  <li>Robot Operation System (ROS)
    <ul>
      <li>Topics, services, rosbags and analysis (shoutout to plotjuggler)</li>
    </ul>
  </li>
  <li>Embedded systems, micro-controllers, and generally small computers (e.g. Raspberry Pis and Nvidia Jetsons)
    <ul>
      <li>When we deploy algorithms, we don’t often get to run them on our personal computers but rather on some other, usually weaker and smaller, computer on board the robot.</li>
      <li>SSH, and working headless.</li>
    </ul>
  </li>
  <li>It may often come in handy to be able to design hardware parts in CAD. After all, we work on physical systems here that may need modifications or additions.</li>
  <li>Git and GitHub</li>
  <li>Python, especially if you are working in machine learning. In this case, PyTorch or Tensorflow are a must. Pytorch3D if you work on, well, 3D. In this case also Open3D (Python and C++) and PCL(C++) could be nice.</li>
  <li>C++ for real-time systems.</li>
</ul>

<h2 id="the-how-interviewing-rules-of-thumb">The How: Interviewing Rules of Thumb</h2>

<p>Before you get to the stage of being interviewed at all, I would try to figure out what kinds of topics you’ll be interacting with in your role or field of study. Once you know that, brush up on relevant knowledge and <strong>implement the algorithms</strong> that are related to it. I find <strong>learning by doing</strong> to be extremely effective (and fun!). Some interviewers like asking for coding-challenges. Either on a board or via some online resource like LeetCode or HackerRank. Make sure to practice those challenges too if you think there is a chance that you’ll be asked to complete one. Finally, practice the “expected” question. “Tell me about yourself,” “tell me about a project you have worked on and your part in it,” “tell me about a challenging time in your professional life,” etc., are all questions you should be able to answer in your sleep (or right after waking up – that would be a bit less creepy). Be concise and confident. I like treating interviews as friendly conversations where the interviewer is genuinely curious to know more about you. So if they are so interested in you, how could you not tell them? :)</p>

<p>In a technical interview, I follow a few simple rules of thumb:</p>

<ul>
  <li>When asked to come up with a solution to a problem,
    <ul>
      <li>Communicate your thoughts! Communicat your assumptions!</li>
      <li>Communicating your assumption about the problem shows that you are communicating well and would also help you to understand the problem better. Literally restating the problem back to the interviewer is good. If you are unsure about something, ask for clarification. [This was introduced to me by some Google employees.]</li>
      <li>As you formulate your solution, always start with the simplest solution you can find. Once you get there, ask if the interviewer would like you to improve on the naive solution.  [This was also introduced to me by some Google employees.]</li>
      <li>I find it better to speak out my thoughts instead of thinking silently. I feel like it keeps the interviewer engaged and shows that you have a clear line of thoughts.</li>
    </ul>
  </li>
  <li>When asked to describe a project,
    <ul>
      <li>Know the tools you have used before. Whether it is YOLO, Octomapping, GTSAM, some other deep learning models or algorithms, make sure you know how they work. You don’t have to be familiar with all the details, but definitely understand the bigger picture. If asked why you chose those tools instead of others, be able to justify your choices.</li>
      <li>If you worked on a team, be able to describe your part in detail.</li>
    </ul>
  </li>
</ul>

<p>And that’s all for today! These are my quick thoughts on the <strong>what</strong> and <strong>how</strong> of robotics interviews and engineering. This post is a bit of a thought-dump – I hope it would at the very least direct you towards some helpful keywords :robot:.</p>]]></content><author><name></name></author><category term="industry" /><summary type="html"><![CDATA[Some thoughts and observations from working and interviewing for robotics engineering teams.]]></summary></entry><entry><title type="html">Welcome Aboard!</title><link href="https://yoraish.com/blog/2023/welcome/" rel="alternate" type="text/html" title="Welcome Aboard!" /><published>2023-05-14T14:14:00+00:00</published><updated>2023-05-14T14:14:00+00:00</updated><id>https://yoraish.com/blog/2023/welcome</id><content type="html" xml:base="https://yoraish.com/blog/2023/welcome/"><![CDATA[<h1 id="welcome-aboard">Welcome Aboard!</h1>
<p>This is the first post in the new website. Previously, this website was hosted <a href="https://yoraish.wordpress.com"> here <a></a></a></p>]]></content><author><name></name></author><category term="random" /><summary type="html"><![CDATA[A new website a new post.]]></summary></entry></feed>